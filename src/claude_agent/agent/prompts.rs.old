//! Prompt messages for claude_agent tool

use crate::tool::PromptProvider;
use rmcp::model::{PromptMessage, PromptMessageRole, PromptMessageContent, PromptArgument};
use super::prompt_args::ClaudeAgentPromptArgs;

/// Prompt provider for claude_agent tool
///
/// This is the ONLY way to provide prompts for claude_agent - tools cannot implement inline.
/// The PromptProvider trait is sealed and can only be implemented in kodegen-mcp-schema.
pub struct ClaudeAgentPrompts;

impl PromptProvider for ClaudeAgentPrompts {
    type PromptArgs = ClaudeAgentPromptArgs;

    fn generate_prompts(args: &Self::PromptArgs) -> Vec<PromptMessage> {
        match args.scenario.as_deref() {
            Some("basic") => prompt_basic_delegation(),
            Some("specialized") => prompt_specialized_agents(),
            Some("parallel") => prompt_parallel_coordination(),
            Some("research") => prompt_research_agents(),
            Some("monitoring") => prompt_progress_monitoring(),
            _ => prompt_comprehensive(),
        }
    }

    fn prompt_arguments() -> Vec<PromptArgument> {
        vec![
            PromptArgument {
                name: "scenario".to_string(),
                title: None,
                description: Some("Scenario: basic, specialized, parallel, research, monitoring".to_string()),
                required: Some(false),
            }
        ]
    }
}

// ============================================================================
// HELPER FUNCTIONS - TEACHING AI AGENTS META-COGNITION
// ============================================================================

/// Teach: Simple task delegation - when to delegate vs handle directly
fn prompt_basic_delegation() -> Vec<PromptMessage> {
    vec![
        PromptMessage {
            role: PromptMessageRole::User,
            content: PromptMessageContent::text(
                "When should I delegate work to a sub-agent using claude_agent? How do I do basic delegation?",
            ),
        },
        PromptMessage {
            role: PromptMessageRole::Assistant,
            content: PromptMessageContent::text(
                "The claude_agent tool enables AI agents to spawn autonomous sub-agents for task delegation. Here's when and how to use it:\n\n\
                 WHEN TO DELEGATE TO A SUB-AGENT:\n\
                 âœ“ Task requires 10+ minutes of focused work\n\
                 âœ“ Task has clear success criteria the agent can verify independently\n\
                 âœ“ You need to continue with other work while the task runs\n\
                 âœ“ Task requires deep exploration of specific directories/files\n\
                 âœ“ Task benefits from isolated context (focused attention)\n\n\
                 WHEN TO HANDLE DIRECTLY (DON'T SPAWN):\n\
                 âœ— Simple 1-2 step tasks (overhead not justified)\n\
                 âœ— Already have necessary context loaded\n\
                 âœ— Task requires cross-cutting coordination across multiple areas\n\
                 âœ— Need immediate result (sub-agent has 2-3s overhead)\n\
                 âœ— Task requires judgment calls only you can make\n\n\
                 BASIC DELEGATION PATTERN:\n\
                 1. SPAWN: Create agent with clear task\n\
                 2. Wait for completion (or check progress with READ)\n\
                 3. Review results\n\
                 4. KILL: Cleanup when done\n\n\
                 EXAMPLE 1: Simple Delegation\n\
                 // Delegate research task to sub-agent\n\
                 claude_agent({\n\
                   \"action\": \"SPAWN\",\n\
                   \"agent\": 0,\n\
                   \"prompt\": \"Search the codebase for all authentication patterns. Document what you find.\",\n\
                   \"max_turns\": 10,\n\
                   \"await_completion_ms\": 300000  // 5 min timeout\n\
                 })\n\
                 // â†’ Returns when complete or after 5 minutes\n\
                 // â†’ Check completed field to see if finished\n\n\
                 EXAMPLE 2: Fire-and-Forget Delegation\n\
                 // Start long-running task in background\n\
                 claude_agent({\n\
                   \"action\": \"SPAWN\",\n\
                   \"agent\": 0,\n\
                   \"prompt\": \"Run all tests and analyze failures. Create detailed report.\",\n\
                   \"max_turns\": 20,\n\
                   \"await_completion_ms\": 0  // Fire-and-forget\n\
                 })\n\
                 // â†’ Returns immediately, agent works in background\n\n\
                 // Check progress later\n\
                 claude_agent({\"action\": \"READ\", \"agent\": 0})\n\
                 // â†’ See current output and status\n\n\
                 EXAMPLE 3: Sequential Refinement\n\
                 // Initial delegation\n\
                 claude_agent({\n\
                   \"action\": \"SPAWN\",\n\
                   \"agent\": 0,\n\
                   \"prompt\": \"Analyze the database schema in src/db\"\n\
                 })\n\n\
                 // Review results, then send follow-up\n\
                 claude_agent({\n\
                   \"action\": \"SEND\",\n\
                   \"agent\": 0,\n\
                   \"prompt\": \"Now check for any missing indexes on foreign keys\"\n\
                 })\n\n\
                 // Another iteration\n\
                 claude_agent({\n\
                   \"action\": \"SEND\",\n\
                   \"agent\": 0,\n\
                   \"prompt\": \"Document your findings in a summary\"\n\
                 })\n\n\
                 // Cleanup\n\
                 claude_agent({\"action\": \"KILL\", \"agent\": 0})\n\n\
                 KEY PARAMETERS:\n\
                 â€¢ action: \"SPAWN\" (create), \"SEND\" (follow-up), \"READ\" (check), \"LIST\" (overview), \"KILL\" (cleanup)\n\
                 â€¢ agent: Instance number (0, 1, 2...) - use different numbers for parallel work\n\
                 â€¢ prompt: Clear task description (required for SPAWN/SEND)\n\
                 â€¢ max_turns: Conversation limit (default: 10) - prevents runaway agents\n\
                 â€¢ await_completion_ms: Timeout in milliseconds\n\
                   - Default: 300000 (5 minutes) - blocks until complete\n\
                   - Custom: Set any timeout\n\
                   - 0: Fire-and-forget (returns immediately)\n\n\
                 DECISION TREE:\n\
                 Is task simple (1-2 steps)? â†’ Handle directly\n\
                 Is task complex (10+ min)? â†’ SPAWN sub-agent\n\
                 Need multiple iterations? â†’ SPAWN, then SEND for refinement\n\
                 Need to continue other work? â†’ SPAWN with await_completion_ms: 0\n\n\
                 RESPONSE FIELDS:\n\
                 â€¢ output: Agent's work (analysis, findings, etc.)\n\
                 â€¢ completed: true if finished, false if still working/timed out\n\
                 â€¢ message_count: Number of conversation turns used\n\
                 â€¢ working: Is agent currently active\n\
                 â€¢ exit_code: 0 = success, non-zero = error (when completed)\n\n\
                 BEST PRACTICES:\n\
                 1. Write clear, specific prompts with success criteria\n\
                 2. Set reasonable max_turns (10-20 for most tasks)\n\
                 3. Use await_completion_ms: 0 for truly long tasks\n\
                 4. Always KILL agents when done to free resources\n\
                 5. Check completed field before trusting results\n\
                 6. Use READ to monitor long-running agents\n\n\
                 Remember: Delegation adds 2-3s overhead. Only delegate when the task justifies it!",
            ),
        },
    ]
}

/// Teach: Tool allowlist/blocklist for constrained agents
fn prompt_specialized_agents() -> Vec<PromptMessage> {
    vec![
        PromptMessage {
            role: PromptMessageRole::User,
            content: PromptMessageContent::text(
                "How do I create specialized sub-agents that can only use specific tools? When would I want to constrain an agent's capabilities?",
            ),
        },
        PromptMessage {
            role: PromptMessageRole::Assistant,
            content: PromptMessageContent::text(
                "You can create specialized sub-agents with constrained tool access using allowed_tools (allowlist) or disallowed_tools (blocklist). This is critical for security, focus, and reliability.\n\n\
                 WHY CONSTRAIN AGENTS:\n\
                 ðŸ”’ Security: Prevent agents from executing code or modifying files\n\
                 ðŸŽ¯ Focus: Force agent to use only relevant tools for the task\n\
                 âš¡ Performance: Reduce decision paralysis from too many tool options\n\
                 âœ… Reliability: Ensure agent can't accidentally break things\n\n\
                 TWO APPROACHES:\n\n\
                 1. ALLOWLIST (allowed_tools): Agent can ONLY use these tools\n\
                 2. BLOCKLIST (disallowed_tools): Agent can use anything EXCEPT these tools\n\n\
                 EXAMPLE 1: Read-Only Research Agent\n\
                 // Create agent that can ONLY read files and search\n\
                 // Cannot write, execute, or modify anything\n\
                 claude_agent({\n\
                   \"action\": \"SPAWN\",\n\
                   \"agent\": 0,\n\
                   \"prompt\": \"Research authentication patterns in src/auth. Document all findings.\",\n\
                   \"allowed_tools\": [\"fs_read_file\", \"fs_search\", \"grep\"],\n\
                   \"max_turns\": 15\n\
                 })\n\
                 // â†’ Agent can only read and search, cannot modify anything\n\
                 // â†’ Perfect for safe code analysis\n\n\
                 EXAMPLE 2: Code Analysis Agent (No Execution)\n\
                 // Block execution tools while allowing file operations\n\
                 claude_agent({\n\
                   \"action\": \"SPAWN\",\n\
                   \"agent\": 0,\n\
                   \"prompt\": \"Analyze test coverage and identify gaps\",\n\
                   \"disallowed_tools\": [\"terminal\", \"bash\", \"process_kill\"],\n\
                   \"max_turns\": 20\n\
                 })\n\
                 // â†’ Agent can read/write files but cannot execute commands\n\
                 // â†’ Safe for file analysis tasks\n\n\
                 EXAMPLE 3: Database-Focused Agent\n\
                 // Constrain to database tools only\n\
                 claude_agent({\n\
                   \"action\": \"SPAWN\",\n\
                   \"agent\": 0,\n\
                   \"prompt\": \"Analyze database schema and suggest optimizations\",\n\
                   \"allowed_tools\": [\n\
                     \"database_query\",\n\
                     \"database_schema\",\n\
                     \"fs_read_file\"  // Can read schema files\n\
                   ],\n\
                   \"max_turns\": 15\n\
                 })\n\
                 // â†’ Focused on database work only\n\n\
                 EXAMPLE 4: Testing Agent (Execute But Don't Modify)\n\
                 // Allow test execution but prevent file modifications\n\
                 claude_agent({\n\
                   \"action\": \"SPAWN\",\n\
                   \"agent\": 0,\n\
                   \"prompt\": \"Run test suite and analyze failures\",\n\
                   \"allowed_tools\": [\"terminal\", \"fs_read_file\", \"fs_search\"],\n\
                   \"max_turns\": 20\n\
                 })\n\
                 // â†’ Can run commands and read files\n\
                 // â†’ Cannot write/edit/delete files\n\n\
                 EXAMPLE 5: Documentation Agent\n\
                 // Allow writing but prevent execution\n\
                 claude_agent({\n\
                   \"action\": \"SPAWN\",\n\
                   \"agent\": 0,\n\
                   \"prompt\": \"Create comprehensive API documentation from source code\",\n\
                   \"disallowed_tools\": [\"terminal\", \"bash\", \"process_kill\", \"process_list\"],\n\
                   \"max_turns\": 30\n\
                 })\n\
                 // â†’ Can read code and write docs\n\
                 // â†’ Cannot execute anything\n\n\
                 COMMON TOOL CATEGORIES:\n\n\
                 File Operations (Read):\n\
                 â€¢ fs_read_file, fs_read_multiple_files\n\
                 â€¢ fs_search, grep\n\
                 â€¢ fs_list_directory, fs_get_file_info\n\n\
                 File Operations (Write):\n\
                 â€¢ fs_write_file\n\
                 â€¢ fs_edit_block\n\
                 â€¢ fs_create_directory, fs_delete_file, fs_delete_directory\n\n\
                 Execution:\n\
                 â€¢ terminal\n\
                 â€¢ bash\n\
                 â€¢ process_kill, process_list\n\n\
                 Version Control:\n\
                 â€¢ git_clone, git_diff\n\
                 â€¢ github_search_code, github_get_file_contents\n\n\
                 Database:\n\
                 â€¢ database_query\n\
                 â€¢ database_schema\n\n\
                 Web/Research:\n\
                 â€¢ browser_agent, browser_research\n\
                 â€¢ web_search\n\
                 â€¢ scrape_url\n\n\
                 SECURITY PATTERNS:\n\n\
                 1. Read-Only Agent (Research/Analysis):\n\
                 allowed_tools: [\"fs_read_file\", \"fs_search\", \"grep\"]\n\n\
                 2. Safe Writer (Documentation/Logs):\n\
                 allowed_tools: [\"fs_read_file\", \"fs_write_file\", \"fs_search\"]\n\
                 disallowed_tools: [\"terminal\", \"bash\", \"fs_delete_file\"]\n\n\
                 3. Test Runner (Execute But Don't Modify):\n\
                 allowed_tools: [\"terminal\", \"fs_read_file\"]\n\n\
                 4. Database Analyst:\n\
                 allowed_tools: [\"database_query\", \"database_schema\", \"fs_read_file\"]\n\n\
                 TOOL CONSTRAINT SYNTAX:\n\
                 // Single tool (string)\n\
                 \"allowed_tools\": \"fs_read_file\"\n\n\
                 // Multiple tools (array)\n\
                 \"allowed_tools\": [\"fs_read_file\", \"fs_search\", \"grep\"]\n\n\
                 // Empty array = no constraints\n\
                 \"allowed_tools\": []  // Agent can use any tool\n\n\
                 COMBINING WITH OTHER PARAMETERS:\n\
                 claude_agent({\n\
                   \"action\": \"SPAWN\",\n\
                   \"agent\": 0,\n\
                   \"prompt\": \"Analyze test coverage\",\n\
                   \"allowed_tools\": [\"fs_read_file\", \"fs_search\", \"terminal\"],\n\
                   \"add_dirs\": [\"./tests\", \"./src\"],  // Context loading\n\
                   \"cwd\": \"/project/backend\",  // Working directory\n\
                   \"max_turns\": 15\n\
                 })\n\n\
                 WHEN TO USE ALLOWLIST vs BLOCKLIST:\n\
                 â€¢ allowed_tools: When you know exactly what agent needs (more restrictive)\n\
                 â€¢ disallowed_tools: When you want to block specific dangerous tools\n\
                 â€¢ Cannot use both - choose one approach\n\n\
                 BEST PRACTICES:\n\
                 1. Default to allowlist for security-sensitive tasks\n\
                 2. Include fs_read_file in most allowlists (agents need to read)\n\
                 3. Always block terminal/bash for read-only agents\n\
                 4. Test constraints - agent will error if it tries blocked tool\n\
                 5. Be generous with search tools (fs_search, grep) for research\n\n\
                 Remember: Constrained agents are safer, faster, and more focused. Use tool restrictions whenever the task allows!",
            ),
        },
    ]
}

/// Teach: Multiple agents working concurrently, synthesizing results
fn prompt_parallel_coordination() -> Vec<PromptMessage> {
    vec![
        PromptMessage {
            role: PromptMessageRole::User,
            content: PromptMessageContent::text(
                "How do I spawn multiple sub-agents to work on different tasks in parallel? How do I coordinate them and synthesize results?",
            ),
        },
        PromptMessage {
            role: PromptMessageRole::Assistant,
            content: PromptMessageContent::text(
                "You can spawn multiple sub-agents using different agent numbers (0, 1, 2...) to work on independent tasks concurrently. This is powerful for parallel processing and complex workflows.\n\n\
                 PARALLEL AGENT PATTERN:\n\
                 1. SPAWN multiple agents with different numbers\n\
                 2. Each agent works independently and concurrently\n\
                 3. Use LIST to check overview\n\
                 4. Use READ to get individual results\n\
                 5. Synthesize results yourself (main agent)\n\
                 6. KILL all agents when done\n\n\
                 EXAMPLE 1: Parallel Code Analysis\n\
                 // Spawn 3 agents to analyze different parts of codebase\n\
                 \n\
                 // Agent 0: Backend analysis\n\
                 claude_agent({\n\
                   \"action\": \"SPAWN\",\n\
                   \"agent\": 0,\n\
                   \"prompt\": \"Analyze backend code in src/api. Check for security issues, performance problems, and code smells. Create detailed report.\",\n\
                   \"add_dirs\": [\"./src/api\", \"./src/middleware\"],\n\
                   \"allowed_tools\": [\"fs_read_file\", \"fs_search\", \"grep\"],\n\
                   \"await_completion_ms\": 0  // Fire-and-forget\n\
                 })\n\n\
                 // Agent 1: Frontend analysis (runs in parallel)\n\
                 claude_agent({\n\
                   \"action\": \"SPAWN\",\n\
                   \"agent\": 1,\n\
                   \"prompt\": \"Analyze frontend code in src/components. Check for accessibility issues, performance, unused code. Create detailed report.\",\n\
                   \"add_dirs\": [\"./src/components\", \"./src/utils\"],\n\
                   \"allowed_tools\": [\"fs_read_file\", \"fs_search\", \"grep\"],\n\
                   \"await_completion_ms\": 0\n\
                 })\n\n\
                 // Agent 2: Test coverage analysis (runs in parallel)\n\
                 claude_agent({\n\
                   \"action\": \"SPAWN\",\n\
                   \"agent\": 2,\n\
                   \"prompt\": \"Analyze test coverage. Run tests and identify gaps. Create report with recommendations.\",\n\
                   \"add_dirs\": [\"./tests\"],\n\
                   \"allowed_tools\": [\"fs_read_file\", \"fs_search\", \"terminal\"],\n\
                   \"await_completion_ms\": 0\n\
                 })\n\n\
                 // Check status of all agents\n\
                 claude_agent({\"action\": \"LIST\"})\n\
                 // â†’ Shows all 3 agents with working status\n\n\
                 // Wait a bit, then read results\n\
                 claude_agent({\"action\": \"READ\", \"agent\": 0})  // Backend results\n\
                 claude_agent({\"action\": \"READ\", \"agent\": 1})  // Frontend results\n\
                 claude_agent({\"action\": \"READ\", \"agent\": 2})  // Test results\n\n\
                 // Synthesize findings yourself\n\
                 // Combine insights from all 3 agents\n\
                 // Create master report\n\n\
                 // Cleanup all agents\n\
                 claude_agent({\"action\": \"KILL\", \"agent\": 0})\n\
                 claude_agent({\"action\": \"KILL\", \"agent\": 1})\n\
                 claude_agent({\"action\": \"KILL\", \"agent\": 2})\n\n\
                 EXAMPLE 2: Parallel Research Tasks\n\
                 // Spawn agents to research different topics\n\
                 \n\
                 claude_agent({\n\
                   \"action\": \"SPAWN\",\n\
                   \"agent\": 0,\n\
                   \"prompt\": \"Research how authentication is implemented. Check all auth-related files.\",\n\
                   \"add_dirs\": [\"./src/auth\"],\n\
                   \"await_completion_ms\": 0\n\
                 })\n\n\
                 claude_agent({\n\
                   \"action\": \"SPAWN\",\n\
                   \"agent\": 1,\n\
                   \"prompt\": \"Research how database connections are managed. Check connection pooling.\",\n\
                   \"add_dirs\": [\"./src/db\"],\n\
                   \"await_completion_ms\": 0\n\
                 })\n\n\
                 claude_agent({\n\
                   \"action\": \"SPAWN\",\n\
                   \"agent\": 2,\n\
                   \"prompt\": \"Research how errors are handled. Check error types and propagation.\",\n\
                   \"add_dirs\": [\"./src/errors\"],\n\
                   \"await_completion_ms\": 0\n\
                 })\n\n\
                 // Later, collect all findings\n\
                 claude_agent({\"action\": \"READ\", \"agent\": 0})\n\
                 claude_agent({\"action\": \"READ\", \"agent\": 1})\n\
                 claude_agent({\"action\": \"READ\", \"agent\": 2})\n\n\
                 EXAMPLE 3: Parallel Testing Across Environments\n\
                 // Run tests in different environments simultaneously\n\
                 \n\
                 claude_agent({\n\
                   \"action\": \"SPAWN\",\n\
                   \"agent\": 0,\n\
                   \"prompt\": \"Run unit tests and report results\",\n\
                   \"allowed_tools\": [\"terminal\", \"fs_read_file\"],\n\
                   \"await_completion_ms\": 0\n\
                 })\n\n\
                 claude_agent({\n\
                   \"action\": \"SPAWN\",\n\
                   \"agent\": 1,\n\
                   \"prompt\": \"Run integration tests and report results\",\n\
                   \"allowed_tools\": [\"terminal\", \"fs_read_file\"],\n\
                   \"await_completion_ms\": 0\n\
                 })\n\n\
                 claude_agent({\n\
                   \"action\": \"SPAWN\",\n\
                   \"agent\": 2,\n\
                   \"prompt\": \"Run linting and format checks\",\n\
                   \"allowed_tools\": [\"terminal\"],\n\
                   \"await_completion_ms\": 0\n\
                 })\n\n\
                 // Monitor progress\n\
                 claude_agent({\"action\": \"LIST\"})\n\n\
                 EXAMPLE 4: Divide-and-Conquer File Processing\n\
                 // Split large task across multiple agents\n\
                 \n\
                 claude_agent({\n\
                   \"action\": \"SPAWN\",\n\
                   \"agent\": 0,\n\
                   \"prompt\": \"Process all .rs files in src/api and extract function signatures\",\n\
                   \"add_dirs\": [\"./src/api\"],\n\
                   \"await_completion_ms\": 0\n\
                 })\n\n\
                 claude_agent({\n\
                   \"action\": \"SPAWN\",\n\
                   \"agent\": 1,\n\
                   \"prompt\": \"Process all .rs files in src/db and extract function signatures\",\n\
                   \"add_dirs\": [\"./src/db\"],\n\
                   \"await_completion_ms\": 0\n\
                 })\n\n\
                 claude_agent({\n\
                   \"action\": \"SPAWN\",\n\
                   \"agent\": 2,\n\
                   \"prompt\": \"Process all .rs files in src/utils and extract function signatures\",\n\
                   \"add_dirs\": [\"./src/utils\"],\n\
                   \"await_completion_ms\": 0\n\
                 })\n\n\
                 // Collect and merge results\n\
                 claude_agent({\"action\": \"READ\", \"agent\": 0})\n\
                 claude_agent({\"action\": \"READ\", \"agent\": 1})\n\
                 claude_agent({\"action\": \"READ\", \"agent\": 2})\n\
                 // â†’ Merge all function signatures into master list\n\n\
                 MONITORING PARALLEL AGENTS:\n\n\
                 // See all agents at once\n\
                 claude_agent({\"action\": \"LIST\"})\n\
                 // Returns:\n\
                 // [\n\
                 //   {agent: 0, message_count: 5, working: true, completed: false},\n\
                 //   {agent: 1, message_count: 3, working: true, completed: false},\n\
                 //   {agent: 2, message_count: 7, working: false, completed: true}\n\
                 // ]\n\n\
                 // Check specific agent\n\
                 claude_agent({\"action\": \"READ\", \"agent\": 2})\n\
                 // â†’ Get detailed output from agent 2\n\n\
                 COORDINATION PATTERNS:\n\n\
                 1. Fire-and-Forget All:\n\
                    - SPAWN all with await_completion_ms: 0\n\
                    - Use LIST to monitor\n\
                    - READ when completed\n\n\
                 2. Staged Parallel:\n\
                    - SPAWN first batch\n\
                    - Wait for completion\n\
                    - SPAWN second batch based on results\n\n\
                 3. Rolling Window:\n\
                    - SPAWN agents 0-2\n\
                    - As each completes, KILL and reuse number for next task\n\
                    - Maintains max 3 concurrent agents\n\n\
                 RESULT SYNTHESIS:\n\n\
                 After collecting results from parallel agents:\n\
                 1. Compare findings across agents\n\
                 2. Identify patterns and conflicts\n\
                 3. Merge insights into coherent report\n\
                 4. Resolve discrepancies\n\
                 5. Create unified action plan\n\n\
                 YOU (main agent) do the synthesis - sub-agents just gather data.\n\n\
                 AGENT NUMBERING:\n\
                 â€¢ Each agent has unique number (0, 1, 2, 3...)\n\
                 â€¢ Numbers are reusable after KILL\n\
                 â€¢ Use consistent numbering for easier tracking\n\
                 â€¢ Recommendation: 0-9 for most workflows\n\n\
                 WHEN TO USE PARALLEL AGENTS:\n\
                 âœ“ Multiple independent research areas\n\
                 âœ“ Analyzing different parts of large codebase\n\
                 âœ“ Running tests across different suites\n\
                 âœ“ Processing multiple files/directories\n\
                 âœ“ Exploring multiple solution approaches\n\n\
                 WHEN NOT TO USE PARALLEL:\n\
                 âœ— Tasks depend on each other (use sequential SEND instead)\n\
                 âœ— Limited resources (each agent consumes CPU/memory)\n\
                 âœ— Results must be processed sequentially\n\
                 âœ— Simple tasks (overhead not justified)\n\n\
                 BEST PRACTICES:\n\
                 1. Keep parallel agents focused on independent tasks\n\
                 2. Use fire-and-forget (await_completion_ms: 0) for true parallelism\n\
                 3. Set reasonable max_turns for each agent\n\
                 4. Use LIST to get overview before reading individual results\n\
                 5. Always KILL agents when done to free resources\n\
                 6. Limit concurrent agents to 3-5 for most tasks\n\
                 7. YOU synthesize results - don't spawn another agent for that\n\n\
                 Remember: Parallel agents enable divide-and-conquer strategies. Spawn multiple focused agents, let them work independently, then synthesize results yourself!",
            ),
        },
    ]
}

/// Teach: add_dirs for deep context, research-focused patterns
fn prompt_research_agents() -> Vec<PromptMessage> {
    vec![
        PromptMessage {
            role: PromptMessageRole::User,
            content: PromptMessageContent::text(
                "How do I create research-focused sub-agents that have deep context from specific directories? What is add_dirs and when should I use it?",
            ),
        },
        PromptMessage {
            role: PromptMessageRole::Assistant,
            content: PromptMessageContent::text(
                "Research agents benefit from loading deep context using add_dirs parameter. This pre-loads directory contents into the agent's context, enabling thorough analysis without repeated file reads.\n\n\
                 WHAT IS add_dirs:\n\
                 â€¢ Loads directory structure and file contents into agent context\n\
                 â€¢ Agent can reference files without explicit fs_read_file calls\n\
                 â€¢ Enables comprehensive understanding of codebase sections\n\
                 â€¢ Critical for research tasks requiring broad context\n\n\
                 WHEN TO USE add_dirs:\n\
                 âœ“ Agent needs to analyze entire directory structure\n\
                 âœ“ Task requires understanding relationships between many files\n\
                 âœ“ Research across multiple related directories\n\
                 âœ“ Code review of specific modules\n\
                 âœ“ Documentation generation from source\n\n\
                 WHEN NOT TO USE add_dirs:\n\
                 âœ— Agent only needs 1-2 specific files (use fs_read_file instead)\n\
                 âœ— Directories contain large binary files\n\
                 âœ— Very large directories (100+ files) - may hit context limits\n\
                 âœ— Agent doesn't need file contents (just structure)\n\n\
                 EXAMPLE 1: Deep Authentication Research\n\
                 // Load all auth-related code into agent context\n\
                 claude_agent({\n\
                   \"action\": \"SPAWN\",\n\
                   \"agent\": 0,\n\
                   \"prompt\": \"Analyze our authentication implementation. Check for security vulnerabilities, code quality issues, and best practices. Document the entire authentication flow.\",\n\
                   \"add_dirs\": [\n\
                     \"./src/auth\",\n\
                     \"./src/middleware/auth\",\n\
                     \"./tests/auth\"\n\
                   ],\n\
                   \"allowed_tools\": [\"fs_read_file\", \"fs_search\", \"grep\"],\n\
                   \"max_turns\": 20\n\
                 })\n\
                 // â†’ Agent has full context of all auth code\n\
                 // â†’ Can reference any file without re-reading\n\
                 // â†’ Understands relationships between files\n\n\
                 EXAMPLE 2: API Documentation Generation\n\
                 // Load API code for comprehensive docs\n\
                 claude_agent({\n\
                   \"action\": \"SPAWN\",\n\
                   \"agent\": 0,\n\
                   \"prompt\": \"Generate comprehensive API documentation. Include all endpoints, request/response formats, error codes, and examples. Create markdown docs.\",\n\
                   \"add_dirs\": [\n\
                     \"./src/api/routes\",\n\
                     \"./src/api/handlers\",\n\
                     \"./src/api/models\"\n\
                   ],\n\
                   \"disallowed_tools\": [\"terminal\", \"bash\"],\n\
                   \"max_turns\": 30\n\
                 })\n\
                 // â†’ Agent sees entire API structure\n\
                 // â†’ Can create accurate, complete documentation\n\n\
                 EXAMPLE 3: Database Schema Analysis\n\
                 // Research database implementation\n\
                 claude_agent({\n\
                   \"action\": \"SPAWN\",\n\
                   \"agent\": 0,\n\
                   \"prompt\": \"Analyze database schema, migrations, and queries. Check for:\n\
                     - Missing indexes on foreign keys\n\
                     - N+1 query patterns\n\
                     - Inefficient queries\n\
                     - Schema consistency issues\n\
                   Create detailed report with recommendations.\",\n\
                   \"add_dirs\": [\n\
                     \"./src/db/schema\",\n\
                     \"./src/db/migrations\",\n\
                     \"./src/db/queries\"\n\
                   ],\n\
                   \"allowed_tools\": [\n\
                     \"fs_read_file\",\n\
                     \"fs_search\",\n\
                     \"database_schema\",\n\
                     \"database_query\"\n\
                   ],\n\
                   \"max_turns\": 25\n\
                 })\n\n\
                 EXAMPLE 4: Code Quality Review\n\
                 // Deep dive into module quality\n\
                 claude_agent({\n\
                   \"action\": \"SPAWN\",\n\
                   \"agent\": 0,\n\
                   \"prompt\": \"Perform comprehensive code review of the user service module. Check:\n\
                     - Code organization and architecture\n\
                     - Error handling patterns\n\
                     - Test coverage\n\
                     - Performance concerns\n\
                     - Security issues\n\
                   Provide specific recommendations with file:line references.\",\n\
                   \"add_dirs\": [\n\
                     \"./src/services/user\",\n\
                     \"./tests/services/user\"\n\
                   ],\n\
                   \"allowed_tools\": [\"fs_read_file\", \"fs_search\", \"grep\"],\n\
                   \"max_turns\": 20\n\
                 })\n\n\
                 EXAMPLE 5: Migration Impact Analysis\n\
                 // Research before making changes\n\
                 claude_agent({\n\
                   \"action\": \"SPAWN\",\n\
                   \"agent\": 0,\n\
                   \"prompt\": \"We're planning to migrate from Express to Fastify. Analyze our current Express usage:\n\
                     - All Express-specific patterns\n\
                     - Middleware dependencies\n\
                     - Route definitions\n\
                     - Request/response handling\n\
                   Estimate migration complexity and identify challenges.\",\n\
                   \"add_dirs\": [\n\
                     \"./src/api\",\n\
                     \"./src/middleware\",\n\
                     \"./src/routes\"\n\
                   ],\n\
                   \"allowed_tools\": [\"fs_read_file\", \"fs_search\", \"grep\"],\n\
                   \"max_turns\": 25,\n\
                   \"await_completion_ms\": 600000  // 10 min timeout for deep research\n\
                 })\n\n\
                 EXAMPLE 6: Parallel Research with Different Contexts\n\
                 // Each agent researches different area\n\
                 \n\
                 // Agent 0: Frontend research\n\
                 claude_agent({\n\
                   \"action\": \"SPAWN\",\n\
                   \"agent\": 0,\n\
                   \"prompt\": \"Research frontend architecture and component patterns\",\n\
                   \"add_dirs\": [\"./src/components\", \"./src/hooks\", \"./src/utils\"],\n\
                   \"await_completion_ms\": 0\n\
                 })\n\n\
                 // Agent 1: Backend research (parallel, different context)\n\
                 claude_agent({\n\
                   \"action\": \"SPAWN\",\n\
                   \"agent\": 1,\n\
                   \"prompt\": \"Research backend architecture and service patterns\",\n\
                   \"add_dirs\": [\"./src/services\", \"./src/controllers\", \"./src/models\"],\n\
                   \"await_completion_ms\": 0\n\
                 })\n\n\
                 // Agent 2: Infrastructure research (parallel, different context)\n\
                 claude_agent({\n\
                   \"action\": \"SPAWN\",\n\
                   \"agent\": 2,\n\
                   \"prompt\": \"Research deployment and infrastructure setup\",\n\
                   \"add_dirs\": [\"./infra\", \"./docker\", \"./scripts\"],\n\
                   \"await_completion_ms\": 0\n\
                 })\n\n\
                 add_dirs SYNTAX:\n\n\
                 // Single directory (string)\n\
                 \"add_dirs\": \"./src/auth\"\n\n\
                 // Multiple directories (array)\n\
                 \"add_dirs\": [\"./src/auth\", \"./src/middleware\", \"./tests/auth\"]\n\n\
                 // Relative or absolute paths\n\
                 \"add_dirs\": [\"./src\", \"/absolute/path/to/dir\"]\n\n\
                 COMBINING WITH OTHER PARAMETERS:\n\
                 claude_agent({\n\
                   \"action\": \"SPAWN\",\n\
                   \"agent\": 0,\n\
                   \"prompt\": \"Research and document\",\n\
                   \"add_dirs\": [\"./src/api\"],  // Load context\n\
                   \"cwd\": \"/project/backend\",  // Working directory\n\
                   \"allowed_tools\": [\"fs_read_file\", \"fs_search\"],  // Tool constraints\n\
                   \"max_turns\": 20,\n\
                   \"await_completion_ms\": 600000\n\
                 })\n\n\
                 RESEARCH WORKFLOW PATTERN:\n\n\
                 1. Initial broad research:\n\
                 claude_agent({\n\
                   \"action\": \"SPAWN\",\n\
                   \"agent\": 0,\n\
                   \"prompt\": \"Survey the authentication system. What patterns are used?\",\n\
                   \"add_dirs\": [\"./src/auth\"]\n\
                 })\n\n\
                 2. Follow-up with specific questions:\n\
                 claude_agent({\n\
                   \"action\": \"SEND\",\n\
                   \"agent\": 0,\n\
                   \"prompt\": \"I see JWT tokens are used. How is token refresh implemented?\"\n\
                 })\n\n\
                 3. Deep dive:\n\
                 claude_agent({\n\
                   \"action\": \"SEND\",\n\
                   \"agent\": 0,\n\
                   \"prompt\": \"Check for security vulnerabilities in the refresh token flow\"\n\
                 })\n\n\
                 4. Get final report:\n\
                 claude_agent({\n\
                   \"action\": \"SEND\",\n\
                   \"agent\": 0,\n\
                   \"prompt\": \"Summarize all findings with specific recommendations\"\n\
                 })\n\n\
                 CONTEXT LIMITS:\n\
                 â€¢ Each directory adds to agent's context window\n\
                 â€¢ Very large directories may hit limits\n\
                 â€¢ If context too large, agent will truncate or fail\n\
                 â€¢ Recommendation: 3-5 focused directories\n\
                 â€¢ For huge codebases, split into multiple agents\n\n\
                 BEST PRACTICES:\n\n\
                 1. Load related directories together:\n\
                    add_dirs: [\"./src/auth\", \"./tests/auth\"]  // Implementation + tests\n\n\
                 2. Use specific directories, not root:\n\
                    âœ“ add_dirs: [\"./src/api\", \"./src/models\"]\n\
                    âœ— add_dirs: [\"./\"]  // Too broad, too much content\n\n\
                 3. Combine with tool constraints for safety:\n\
                    add_dirs: [\"./src\"],\n\
                    allowed_tools: [\"fs_read_file\", \"fs_search\"]  // Read-only\n\n\
                 4. Set higher max_turns for research:\n\
                    max_turns: 20-30  // Research needs exploration\n\n\
                 5. Use longer timeouts:\n\
                    await_completion_ms: 600000  // 10 min for deep research\n\n\
                 6. Provide specific research questions in prompt:\n\
                    \"Check for X, Y, Z. Document findings with examples.\"\n\n\
                 7. Enable iterative refinement with SEND:\n\
                    SPAWN â†’ review results â†’ SEND follow-up questions\n\n\
                 Remember: add_dirs loads deep context enabling comprehensive research. Use it when agents need to understand entire modules or systems, not just individual files!",
            ),
        },
    ]
}

/// Teach: READ action, timeout handling, background execution
fn prompt_progress_monitoring() -> Vec<PromptMessage> {
    vec![
        PromptMessage {
            role: PromptMessageRole::User,
            content: PromptMessageContent::text(
                "How do I monitor the progress of long-running sub-agents? How do I handle timeouts and background execution?",
            ),
        },
        PromptMessage {
            role: PromptMessageRole::Assistant,
            content: PromptMessageContent::text(
                "You can monitor sub-agent progress using READ action and control execution timing with await_completion_ms. This enables fire-and-forget patterns and long-running background agents.\n\n\
                 THREE EXECUTION MODES:\n\n\
                 1. BLOCKING (Default):\n\
                    await_completion_ms: 300000  // 5 minutes\n\
                    â†’ Waits up to 5 minutes for completion\n\
                    â†’ Returns results when done or current state at timeout\n\
                    â†’ Agent continues in background if times out\n\n\
                 2. FIRE-AND-FORGET:\n\
                    await_completion_ms: 0\n\
                    â†’ Returns immediately\n\
                    â†’ Agent runs entirely in background\n\
                    â†’ Use READ to check progress\n\n\
                 3. CUSTOM TIMEOUT:\n\
                    await_completion_ms: 120000  // 2 minutes\n\
                    â†’ Wait exactly 2 minutes\n\
                    â†’ Useful for known-duration tasks\n\n\
                 MONITORING WITH READ ACTION:\n\n\
                 READ checks agent status without sending new prompts.\n\
                 \n\
                 claude_agent({\"action\": \"READ\", \"agent\": 0})\n\
                 \n\
                 Returns:\n\
                 â€¢ output: Current agent work and findings\n\
                 â€¢ message_count: Conversation turns used\n\
                 â€¢ working: Is agent currently active (true/false)\n\
                 â€¢ completed: Has agent finished (true/false)\n\
                 â€¢ exit_code: 0 = success, non-zero = error (when completed)\n\n\
                 EXAMPLE 1: Fire-and-Forget with Periodic Monitoring\n\
                 // Start long-running research agent\n\
                 claude_agent({\n\
                   \"action\": \"SPAWN\",\n\
                   \"agent\": 0,\n\
                   \"prompt\": \"Perform comprehensive security audit of entire codebase. Check for vulnerabilities, insecure patterns, exposed secrets, and create detailed report.\",\n\
                   \"add_dirs\": [\"./src\", \"./tests\"],\n\
                   \"max_turns\": 30,\n\
                   \"await_completion_ms\": 0  // Fire-and-forget\n\
                 })\n\
                 // â†’ Returns immediately, agent works in background\n\n\
                 // Continue with other work...\n\
                 // ...\n\n\
                 // Check progress later (1st check)\n\
                 claude_agent({\"action\": \"READ\", \"agent\": 0})\n\
                 // â†’ {working: true, completed: false, message_count: 8, output: \"...current findings...\"}\n\n\
                 // Continue other work...\n\
                 // ...\n\n\
                 // Check again later (2nd check)\n\
                 claude_agent({\"action\": \"READ\", \"agent\": 0})\n\
                 // â†’ {working: true, completed: false, message_count: 15, output: \"...more findings...\"}\n\n\
                 // Finally check completion\n\
                 claude_agent({\"action\": \"READ\", \"agent\": 0})\n\
                 // â†’ {working: false, completed: true, exit_code: 0, output: \"...final report...\"}\n\n\
                 EXAMPLE 2: Timeout Handling\n\
                 // Start with reasonable timeout\n\
                 let result = claude_agent({\n\
                   \"action\": \"SPAWN\",\n\
                   \"agent\": 0,\n\
                   \"prompt\": \"Analyze database performance issues\",\n\
                   \"await_completion_ms\": 120000  // 2 min timeout\n\
                 })\n\n\
                 // Check if completed\n\
                 if (result.completed) {\n\
                   // Agent finished within 2 minutes\n\
                   console.log(\"Analysis complete:\", result.output)\n\
                 } else {\n\
                   // Timed out, agent still working in background\n\
                   console.log(\"Still working, current progress:\", result.output)\n\
                   \n\
                   // Check again later\n\
                   let final = claude_agent({\"action\": \"READ\", \"agent\": 0})\n\
                   if (final.completed) {\n\
                     console.log(\"Now complete:\", final.output)\n\
                   }\n\
                 }\n\n\
                 EXAMPLE 3: Parallel Agents with Monitoring\n\
                 // Start 3 agents in fire-and-forget mode\n\
                 claude_agent({\n\
                   \"action\": \"SPAWN\",\n\
                   \"agent\": 0,\n\
                   \"prompt\": \"Task A - analyze frontend\",\n\
                   \"await_completion_ms\": 0\n\
                 })\n\n\
                 claude_agent({\n\
                   \"action\": \"SPAWN\",\n\
                   \"agent\": 1,\n\
                   \"prompt\": \"Task B - analyze backend\",\n\
                   \"await_completion_ms\": 0\n\
                 })\n\n\
                 claude_agent({\n\
                   \"action\": \"SPAWN\",\n\
                   \"agent\": 2,\n\
                   \"prompt\": \"Task C - analyze tests\",\n\
                   \"await_completion_ms\": 0\n\
                 })\n\n\
                 // Monitor all agents\n\
                 claude_agent({\"action\": \"LIST\"})\n\
                 // â†’ Shows status of all 3 agents\n\n\
                 // Wait for all to complete\n\
                 let allDone = false;\n\
                 while (!allDone) {\n\
                   let status = claude_agent({\"action\": \"LIST\"})\n\
                   allDone = status.agents.every(a => a.completed)\n\
                   // Sleep/wait between checks\n\
                 }\n\n\
                 // Read final results\n\
                 claude_agent({\"action\": \"READ\", \"agent\": 0})\n\
                 claude_agent({\"action\": \"READ\", \"agent\": 1})\n\
                 claude_agent({\"action\": \"READ\", \"agent\": 2})\n\n\
                 EXAMPLE 4: Progressive Refinement\n\
                 // Start initial analysis\n\
                 claude_agent({\n\
                   \"action\": \"SPAWN\",\n\
                   \"agent\": 0,\n\
                   \"prompt\": \"Survey authentication implementation\",\n\
                   \"add_dirs\": [\"./src/auth\"],\n\
                   \"await_completion_ms\": 0\n\
                 })\n\n\
                 // Do other work, then check progress\n\
                 let progress = claude_agent({\"action\": \"READ\", \"agent\": 0})\n\
                 console.log(\"Initial findings:\", progress.output)\n\n\
                 // Send follow-up based on initial findings\n\
                 claude_agent({\n\
                   \"action\": \"SEND\",\n\
                   \"agent\": 0,\n\
                   \"prompt\": \"I see JWT is used. Now check token refresh security.\",\n\
                   \"await_completion_ms\": 0\n\
                 })\n\n\
                 // Check again\n\
                 progress = claude_agent({\"action\": \"READ\", \"agent\": 0})\n\
                 console.log(\"Deeper findings:\", progress.output)\n\n\
                 // Final refinement\n\
                 claude_agent({\n\
                   \"action\": \"SEND\",\n\
                   \"agent\": 0,\n\
                   \"prompt\": \"Create final security report with recommendations\"\n\
                 })\n\
                 // This one blocks until complete (default timeout)\n\n\
                 UNDERSTANDING RESPONSE FIELDS:\n\n\
                 1. completed: true/false\n\
                    â€¢ true: Agent finished, exit_code is set\n\
                    â€¢ false: Agent still working or timed out\n\n\
                 2. working: true/false\n\
                    â€¢ true: Agent actively processing\n\
                    â€¢ false: Agent idle or finished\n\n\
                 3. exit_code: number or null\n\
                    â€¢ 0: Success (when completed: true)\n\
                    â€¢ non-zero: Error (when completed: true)\n\
                    â€¢ null: Still running (when completed: false)\n\n\
                 4. message_count: number\n\
                    â€¢ How many turns used so far\n\
                    â€¢ Approaches max_turns limit\n\n\
                 5. output: string\n\
                    â€¢ Agent's current work/findings\n\
                    â€¢ Updates as agent progresses\n\
                    â€¢ Final results when completed\n\n\
                 TIMEOUT RECOMMENDATIONS:\n\n\
                 Quick tasks (1-2 min):\n\
                 await_completion_ms: 120000\n\n\
                 Medium tasks (5 min):\n\
                 await_completion_ms: 300000  // Default\n\n\
                 Long tasks (10+ min):\n\
                 await_completion_ms: 600000  // Or use 0 for fire-and-forget\n\n\
                 Very long tasks:\n\
                 await_completion_ms: 0  // Fire-and-forget, use READ\n\n\
                 MONITORING PATTERNS:\n\n\
                 Pattern 1: Poll Until Complete\n\
                 ```\n\
                 while (true) {\n\
                   let status = claude_agent({\"action\": \"READ\", \"agent\": 0})\n\
                   if (status.completed) break\n\
                   // Wait before checking again\n\
                 }\n\
                 ```\n\n\
                 Pattern 2: Check Once, Continue If Done\n\
                 ```\n\
                 let status = claude_agent({\"action\": \"READ\", \"agent\": 0})\n\
                 if (status.completed) {\n\
                   // Process results\n\
                 } else {\n\
                   // Check later\n\
                 }\n\
                 ```\n\n\
                 Pattern 3: Monitor Multiple Agents\n\
                 ```\n\
                 let list = claude_agent({\"action\": \"LIST\"})\n\
                 for (let agent of list.agents) {\n\
                   if (agent.completed) {\n\
                     // Read completed agent\n\
                     claude_agent({\"action\": \"READ\", \"agent\": agent.agent})\n\
                   }\n\
                 }\n\
                 ```\n\n\
                 COMBINING READ WITH SEND:\n\n\
                 // Check progress\n\
                 let status = claude_agent({\"action\": \"READ\", \"agent\": 0})\n\
                 \n\
                 // If not done, send encouragement or redirect\n\
                 if (!status.completed) {\n\
                   claude_agent({\n\
                     \"action\": \"SEND\",\n\
                     \"agent\": 0,\n\
                     \"prompt\": \"Focus on the critical issues first, then document\"\n\
                   })\n\
                 }\n\n\
                 BEST PRACTICES:\n\n\
                 1. Use fire-and-forget for truly long tasks:\n\
                    await_completion_ms: 0\n\n\
                 2. Set reasonable timeouts for known-duration tasks:\n\
                    await_completion_ms: 120000  // 2 min for quick analysis\n\n\
                 3. Always check completed field before trusting results:\n\
                    if (result.completed && result.exit_code === 0) { ... }\n\n\
                 4. Use LIST for multi-agent overview:\n\
                    claude_agent({\"action\": \"LIST\"})\n\n\
                 5. Use READ for detailed status:\n\
                    claude_agent({\"action\": \"READ\", \"agent\": 0})\n\n\
                 6. Don't spam READ - give agents time to work:\n\
                    Wait 30s-1min between checks\n\n\
                 7. Monitor message_count to track progress:\n\
                    Approaching max_turns? Agent may need more turns\n\n\
                 8. Set appropriate max_turns for task complexity:\n\
                    Simple: 10-15 turns\n\
                    Complex: 20-30 turns\n\
                    Research: 30+ turns\n\n\
                 Remember: Fire-and-forget (await_completion_ms: 0) + READ enables true background processing. Start long tasks, continue other work, check progress when convenient!",
            ),
        },
    ]
}

/// Teach: All 5 actions with decision tree for when to use each
fn prompt_comprehensive() -> Vec<PromptMessage> {
    vec![
        PromptMessage {
            role: PromptMessageRole::User,
            content: PromptMessageContent::text(
                "Give me a complete guide to using the claude_agent tool for meta-agent coordination and task delegation.",
            ),
        },
        PromptMessage {
            role: PromptMessageRole::Assistant,
            content: PromptMessageContent::text(
                "The claude_agent tool enables AI agents to spawn and coordinate autonomous sub-agents. This is META-COGNITION - AI agents managing other AI agents.\n\n\
                 ============================================================================\n\
                 FIVE ACTIONS: SPAWN, SEND, READ, LIST, KILL\n\
                 ============================================================================\n\n\
                 ACTION 1: SPAWN - Create New Agent\n\
                 ACTION 2: SEND - Continue Agent Conversation  \n\
                 ACTION 3: READ - Check Agent Progress\n\
                 ACTION 4: LIST - Show All Agents\n\
                 ACTION 5: KILL - Terminate Agent\n\n\
                 ============================================================================\n\
                 ACTION 1: SPAWN - CREATE NEW AGENT SESSION\n\
                 ============================================================================\n\n\
                 Creates autonomous sub-agent with initial task.\n\n\
                 claude_agent({\n\
                   \"action\": \"SPAWN\",\n\
                   \"agent\": 0,\n\
                   \"prompt\": \"Analyze authentication code for security issues\",\n\
                   \"max_turns\": 15,\n\
                   \"await_completion_ms\": 300000\n\
                 })\n\n\
                 SPAWN PARAMETERS:\n\
                 â€¢ agent: Instance number (0, 1, 2...) - use different numbers for parallel work\n\
                 â€¢ prompt: Task description (required)\n\
                 â€¢ max_turns: Conversation limit (default: 10)\n\
                 â€¢ await_completion_ms: Timeout in ms (default: 300000 = 5 min, 0 = fire-and-forget)\n\
                 â€¢ system_prompt: Custom agent behavior\n\
                 â€¢ model: AI model to use (sonnet/opus/haiku)\n\
                 â€¢ cwd: Working directory\n\
                 â€¢ allowed_tools: Tools agent CAN use (allowlist)\n\
                 â€¢ disallowed_tools: Tools agent CANNOT use (blocklist)\n\
                 â€¢ add_dirs: Load directory context\n\n\
                 WHEN TO SPAWN:\n\
                 âœ“ Task requires 10+ minutes of focused work\n\
                 âœ“ Task has clear success criteria\n\
                 âœ“ Need to continue other work while task runs\n\
                 âœ“ Task requires deep directory context\n\
                 âœ“ Multiple independent tasks (spawn multiple agents)\n\
                 âœ“ Need specialized tool constraints\n\n\
                 WHEN NOT TO SPAWN:\n\
                 âœ— Simple 1-2 step tasks (overhead not justified)\n\
                 âœ— Already have necessary context\n\
                 âœ— Need immediate result (2-3s overhead)\n\
                 âœ— Task requires cross-cutting coordination\n\n\
                 ============================================================================\n\
                 ACTION 2: SEND - CONTINUE AGENT CONVERSATION\n\
                 ============================================================================\n\n\
                 Send follow-up prompt to existing agent.\n\n\
                 claude_agent({\n\
                   \"action\": \"SEND\",\n\
                   \"agent\": 0,\n\
                   \"prompt\": \"Now check for missing indexes on foreign keys\"\n\
                 })\n\n\
                 SEND PARAMETERS:\n\
                 â€¢ agent: Which agent to send to\n\
                 â€¢ prompt: Follow-up instruction (required)\n\
                 â€¢ await_completion_ms: Timeout (default: 300000)\n\n\
                 WHEN TO USE SEND:\n\
                 â€¢ Multi-turn dialogue with agent\n\
                 â€¢ Iterative refinement based on results\n\
                 â€¢ Follow-up questions\n\
                 â€¢ Course correction\n\n\
                 SEND vs NEW SPAWN:\n\
                 â€¢ SEND: Continue existing conversation (context preserved)\n\
                 â€¢ SPAWN: Start fresh conversation (new context)\n\n\
                 ============================================================================\n\
                 ACTION 3: READ - CHECK AGENT PROGRESS\n\
                 ============================================================================\n\n\
                 Get current agent output and status.\n\n\
                 claude_agent({\"action\": \"READ\", \"agent\": 0})\n\n\
                 RETURNS:\n\
                 â€¢ output: Agent's current work\n\
                 â€¢ message_count: Turns used\n\
                 â€¢ working: Is agent active\n\
                 â€¢ completed: Has agent finished\n\
                 â€¢ exit_code: 0 = success, non-zero = error (when completed)\n\n\
                 WHEN TO USE READ:\n\
                 â€¢ After timeout (await_completion_ms expired)\n\
                 â€¢ Monitoring background agents\n\
                 â€¢ Checking fire-and-forget agents\n\
                 â€¢ Before sending follow-up\n\n\
                 ============================================================================\n\
                 ACTION 4: LIST - SHOW ALL AGENTS\n\
                 ============================================================================\n\n\
                 See all active agents for this connection.\n\n\
                 claude_agent({\"action\": \"LIST\"})\n\n\
                 RETURNS ARRAY:\n\
                 [\n\
                   {agent: 0, message_count: 5, working: true, completed: false},\n\
                   {agent: 1, message_count: 8, working: false, completed: true},\n\
                   {agent: 2, message_count: 3, working: true, completed: false}\n\
                 ]\n\n\
                 WHEN TO USE LIST:\n\
                 â€¢ Multi-agent overview\n\
                 â€¢ Check parallel work status\n\
                 â€¢ Find which agents are still running\n\
                 â€¢ Resource tracking\n\n\
                 ============================================================================\n\
                 ACTION 5: KILL - TERMINATE AGENT\n\
                 ============================================================================\n\n\
                 Gracefully shutdown agent and cleanup resources.\n\n\
                 claude_agent({\"action\": \"KILL\", \"agent\": 0})\n\n\
                 CLEANUP:\n\
                 â€¢ Terminates subprocess\n\
                 â€¢ Releases resources\n\
                 â€¢ Removes from registry\n\
                 â€¢ Cannot be undone\n\n\
                 WHEN TO KILL:\n\
                 â€¢ Agent finished and results collected\n\
                 â€¢ No longer need agent\n\
                 â€¢ Free resources for other work\n\
                 â€¢ End of workflow\n\n\
                 ============================================================================\n\
                 DECISION TREE: WHICH ACTION TO USE?\n\
                 ============================================================================\n\n\
                 Need to START new task? â†’ SPAWN\n\
                 â€¢ Simple: SPAWN with defaults\n\
                 â€¢ Long: SPAWN with await_completion_ms: 0\n\
                 â€¢ Parallel: SPAWN multiple agents (0, 1, 2...)\n\
                 â€¢ Constrained: SPAWN with allowed_tools\n\
                 â€¢ Research: SPAWN with add_dirs\n\n\
                 Need to REFINE existing work? â†’ SEND\n\
                 â€¢ Follow-up questions\n\
                 â€¢ Course corrections\n\
                 â€¢ Iterative improvements\n\n\
                 Need to CHECK status? â†’ READ\n\
                 â€¢ After timeout\n\
                 â€¢ Background agents\n\
                 â€¢ Before sending follow-up\n\n\
                 Need OVERVIEW of all agents? â†’ LIST\n\
                 â€¢ Multi-agent coordination\n\
                 â€¢ Status dashboard\n\n\
                 Need to CLEANUP? â†’ KILL\n\
                 â€¢ Work complete\n\
                 â€¢ Free resources\n\n\
                 ============================================================================\n\
                 COMMON WORKFLOWS\n\
                 ============================================================================\n\n\
                 WORKFLOW 1: Simple Delegation\n\
                 1. SPAWN agent with task\n\
                 2. Wait for completion\n\
                 3. Review results\n\
                 4. KILL agent\n\n\
                 claude_agent({\"action\": \"SPAWN\", \"agent\": 0, \"prompt\": \"Analyze auth code\"})\n\
                 // â†’ Returns when complete\n\
                 claude_agent({\"action\": \"KILL\", \"agent\": 0})\n\n\
                 WORKFLOW 2: Fire-and-Forget\n\
                 1. SPAWN with await_completion_ms: 0\n\
                 2. Continue other work\n\
                 3. READ to check progress\n\
                 4. Repeat READ until completed\n\
                 5. KILL when done\n\n\
                 claude_agent({\"action\": \"SPAWN\", \"agent\": 0, \"prompt\": \"Long task\", \"await_completion_ms\": 0})\n\
                 // Do other work...\n\
                 claude_agent({\"action\": \"READ\", \"agent\": 0})\n\
                 // Check completed field\n\
                 claude_agent({\"action\": \"KILL\", \"agent\": 0})\n\n\
                 WORKFLOW 3: Iterative Refinement\n\
                 1. SPAWN agent\n\
                 2. Review results\n\
                 3. SEND follow-up\n\
                 4. Repeat 2-3 as needed\n\
                 5. KILL when done\n\n\
                 claude_agent({\"action\": \"SPAWN\", \"agent\": 0, \"prompt\": \"Initial task\"})\n\
                 claude_agent({\"action\": \"SEND\", \"agent\": 0, \"prompt\": \"Now check X\"})\n\
                 claude_agent({\"action\": \"SEND\", \"agent\": 0, \"prompt\": \"Document findings\"})\n\
                 claude_agent({\"action\": \"KILL\", \"agent\": 0})\n\n\
                 WORKFLOW 4: Parallel Processing\n\
                 1. SPAWN multiple agents (0, 1, 2...)\n\
                 2. LIST to check status\n\
                 3. READ each agent for results\n\
                 4. Synthesize results yourself\n\
                 5. KILL all agents\n\n\
                 claude_agent({\"action\": \"SPAWN\", \"agent\": 0, \"prompt\": \"Task A\", \"await_completion_ms\": 0})\n\
                 claude_agent({\"action\": \"SPAWN\", \"agent\": 1, \"prompt\": \"Task B\", \"await_completion_ms\": 0})\n\
                 claude_agent({\"action\": \"SPAWN\", \"agent\": 2, \"prompt\": \"Task C\", \"await_completion_ms\": 0})\n\
                 claude_agent({\"action\": \"LIST\"})  // Check all\n\
                 claude_agent({\"action\": \"READ\", \"agent\": 0})\n\
                 claude_agent({\"action\": \"READ\", \"agent\": 1})\n\
                 claude_agent({\"action\": \"READ\", \"agent\": 2})\n\
                 // Synthesize results\n\
                 claude_agent({\"action\": \"KILL\", \"agent\": 0})\n\
                 claude_agent({\"action\": \"KILL\", \"agent\": 1})\n\
                 claude_agent({\"action\": \"KILL\", \"agent\": 2})\n\n\
                 ============================================================================\n\
                 KEY CONCEPTS\n\
                 ============================================================================\n\n\
                 AGENT NUMBERING:\n\
                 â€¢ Each agent has unique number (0, 1, 2...)\n\
                 â€¢ Use different numbers for parallel work\n\
                 â€¢ Numbers are reusable after KILL\n\
                 â€¢ Connection-isolated (your agent:0 â‰  other connection's agent:0)\n\n\
                 TIMEOUT BEHAVIOR:\n\
                 â€¢ await_completion_ms: 300000 (default) - wait 5 min\n\
                 â€¢ await_completion_ms: 0 - fire-and-forget\n\
                 â€¢ await_completion_ms: custom - wait specific time\n\
                 â€¢ On timeout: returns current state, agent continues in background\n\
                 â€¢ Use READ to check progress after timeout\n\n\
                 TOOL CONSTRAINTS:\n\
                 â€¢ allowed_tools: Allowlist - agent can ONLY use these\n\
                 â€¢ disallowed_tools: Blocklist - agent can use anything EXCEPT these\n\
                 â€¢ Use for security (block terminal) or focus (only fs tools)\n\n\
                 CONTEXT LOADING:\n\
                 â€¢ add_dirs: Pre-load directory contents into agent context\n\
                 â€¢ Critical for deep analysis of specific modules\n\
                 â€¢ Examples: [\"./src/auth\", \"./tests/auth\"]\n\n\
                 MAX TURNS:\n\
                 â€¢ Prevents runaway agents\n\
                 â€¢ Default: 10 turns\n\
                 â€¢ Increase for complex tasks: 20-30\n\
                 â€¢ Agent stops when limit reached\n\n\
                 ============================================================================\n\
                 BEST PRACTICES\n\
                 ============================================================================\n\n\
                 1. DELEGATION:\n\
                    â€¢ Only delegate tasks requiring 10+ minutes\n\
                    â€¢ Write clear prompts with success criteria\n\
                    â€¢ Set appropriate max_turns\n\n\
                 2. TOOL CONSTRAINTS:\n\
                    â€¢ Default to allowlist for security\n\
                    â€¢ Always include fs_read_file for research\n\
                    â€¢ Block terminal for read-only agents\n\n\
                 3. TIMEOUTS:\n\
                    â€¢ Use default (300000) for most tasks\n\
                    â€¢ Use 0 for truly long tasks\n\
                    â€¢ Use custom for known-duration tasks\n\n\
                 4. PARALLEL WORK:\n\
                    â€¢ Limit to 3-5 concurrent agents\n\
                    â€¢ Use LIST for overview\n\
                    â€¢ YOU synthesize results (don't spawn agent for that)\n\n\
                 5. MONITORING:\n\
                    â€¢ Check completed field before trusting results\n\
                    â€¢ Use READ after timeouts\n\
                    â€¢ Don't spam READ - give agents time\n\n\
                 6. CLEANUP:\n\
                    â€¢ Always KILL agents when done\n\
                    â€¢ Free resources for other work\n\
                    â€¢ Don't leave agents running\n\n\
                 7. CONTEXT:\n\
                    â€¢ Use add_dirs for deep analysis\n\
                    â€¢ Load 3-5 focused directories max\n\
                    â€¢ Don't load entire codebase\n\n\
                 ============================================================================\n\
                 EXAMPLE: COMPREHENSIVE SECURITY AUDIT\n\
                 ============================================================================\n\n\
                 // Parallel security audit of different areas\n\
                 \n\
                 // Agent 0: Auth security\n\
                 claude_agent({\n\
                   \"action\": \"SPAWN\",\n\
                   \"agent\": 0,\n\
                   \"prompt\": \"Security audit of authentication. Check for vulnerabilities, exposed secrets, weak patterns.\",\n\
                   \"add_dirs\": [\"./src/auth\", \"./src/middleware/auth\"],\n\
                   \"allowed_tools\": [\"fs_read_file\", \"fs_search\", \"grep\"],\n\
                   \"max_turns\": 20,\n\
                   \"await_completion_ms\": 0\n\
                 })\n\n\
                 // Agent 1: API security\n\
                 claude_agent({\n\
                   \"action\": \"SPAWN\",\n\
                   \"agent\": 1,\n\
                   \"prompt\": \"Security audit of API endpoints. Check for injection risks, rate limiting, input validation.\",\n\
                   \"add_dirs\": [\"./src/api\"],\n\
                   \"allowed_tools\": [\"fs_read_file\", \"fs_search\", \"grep\"],\n\
                   \"max_turns\": 20,\n\
                   \"await_completion_ms\": 0\n\
                 })\n\n\
                 // Agent 2: Database security\n\
                 claude_agent({\n\
                   \"action\": \"SPAWN\",\n\
                   \"agent\": 2,\n\
                   \"prompt\": \"Security audit of database queries. Check for SQL injection, missing parameterization.\",\n\
                   \"add_dirs\": [\"./src/db\"],\n\
                   \"allowed_tools\": [\"fs_read_file\", \"fs_search\", \"database_schema\"],\n\
                   \"max_turns\": 20,\n\
                   \"await_completion_ms\": 0\n\
                 })\n\n\
                 // Check progress\n\
                 claude_agent({\"action\": \"LIST\"})\n\n\
                 // Collect results\n\
                 let auth_audit = claude_agent({\"action\": \"READ\", \"agent\": 0})\n\
                 let api_audit = claude_agent({\"action\": \"READ\", \"agent\": 1})\n\
                 let db_audit = claude_agent({\"action\": \"READ\", \"agent\": 2})\n\n\
                 // YOU synthesize findings into master security report\n\
                 // Identify critical issues, patterns, recommendations\n\n\
                 // Cleanup\n\
                 claude_agent({\"action\": \"KILL\", \"agent\": 0})\n\
                 claude_agent({\"action\": \"KILL\", \"agent\": 1})\n\
                 claude_agent({\"action\": \"KILL\", \"agent\": 2})\n\n\
                 ============================================================================\n\
                 REMEMBER\n\
                 ============================================================================\n\n\
                 This is META-COGNITION: You are an AI agent managing other AI agents.\n\n\
                 SPAWN when:\n\
                 â€¢ Task justifies 10+ min of focused work\n\
                 â€¢ Clear success criteria\n\
                 â€¢ Can work independently\n\n\
                 DELEGATE thoughtfully:\n\
                 â€¢ Not everything needs a sub-agent\n\
                 â€¢ Overhead is 2-3 seconds\n\
                 â€¢ YOU still need to synthesize results\n\n\
                 COORDINATE effectively:\n\
                 â€¢ Use parallel agents for independent tasks\n\
                 â€¢ Use SEND for iterative refinement\n\
                 â€¢ Use READ to monitor progress\n\
                 â€¢ Use LIST for multi-agent overview\n\n\
                 CLEANUP always:\n\
                 â€¢ KILL agents when done\n\
                 â€¢ Free resources\n\
                 â€¢ Don't leave agents running\n\n\
                 You are teaching yourself when to delegate and how to coordinate. Think about thinking!",
            ),
        },
    ]
}
